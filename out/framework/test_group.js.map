{"version":3,"sources":["../../src/framework/test_group.ts"],"names":["allowedTestNameCharacters","paramsEquals","validNames","RegExp","TestGroup","constructor","fixture","Set","iterate","log","test","tests","checkName","name","Error","decodeURIComponent","seen","has","add","fn","Test","push","params","specs","cases","Array","from","spec","some","x","rec","RunCaseSpecific","recorder","id","run","debug","res","record","start","inst","init","finalize","e","threw","finish"],"mappings":"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","sourcesContent":["import { allowedTestNameCharacters } from './allowed_characters.js';\nimport { Fixture } from './fixture.js';\nimport { TestCaseID } from './id.js';\nimport { LiveTestCaseResult, TestCaseRecorder, TestSpecRecorder } from './logger.js';\nimport { ParamSpecIterable, ParamsAny, paramsEquals } from './params/index.js';\n\nexport interface RunCase {\n  readonly id: TestCaseID;\n  run(debug?: boolean): Promise<LiveTestCaseResult>;\n}\n\nexport interface RunCaseIterable {\n  iterate(rec: TestSpecRecorder): Iterable<RunCase>;\n}\n\ntype FixtureClass<F extends Fixture> = new (log: TestCaseRecorder, params: ParamsAny) => F;\ntype TestFn<F extends Fixture> = (t: F) => Promise<void> | void;\n\nconst validNames = new RegExp('^[' + allowedTestNameCharacters + ']+$');\n\nexport class TestGroup<F extends Fixture> implements RunCaseIterable {\n  private fixture: FixtureClass<F>;\n  private seen: Set<string> = new Set();\n  private tests: Array<Test<F>> = [];\n\n  constructor(fixture: FixtureClass<F>) {\n    this.fixture = fixture;\n  }\n\n  *iterate(log: TestSpecRecorder): Iterable<RunCase> {\n    for (const test of this.tests) {\n      yield* test.iterate(log);\n    }\n  }\n\n  private checkName(name: string): void {\n    if (!validNames.test(name)) {\n      throw new Error(`Invalid test name ${name}; must match [${validNames}]+`);\n    }\n    if (name !== decodeURIComponent(name)) {\n      // Shouldn't happen due to the rule above. Just makes sure that treated\n      // unencoded strings as encoded strings is OK.\n      throw new Error(`Not decodeURIComponent-idempotent: ${name} !== ${decodeURIComponent(name)}`);\n    }\n\n    if (this.seen.has(name)) {\n      throw new Error(`Duplicate test name: ${name}`);\n    }\n    this.seen.add(name);\n  }\n\n  // TODO: This could take a fixture, too, to override the one for the group.\n  test(name: string, fn: TestFn<F>): Test<F> {\n    this.checkName(name);\n\n    const test = new Test<F>(name, this.fixture, fn);\n    this.tests.push(test);\n    return test;\n  }\n}\n\n// This test is created when it's inserted, but may be parameterized afterward (.params()).\nclass Test<F extends Fixture> {\n  readonly name: string;\n  readonly fixture: FixtureClass<F>;\n  readonly fn: TestFn<F>;\n  private cases: ParamSpecIterable | null = null;\n\n  constructor(name: string, fixture: FixtureClass<F>, fn: TestFn<F>) {\n    this.name = name;\n    this.fixture = fixture;\n    this.fn = fn;\n  }\n\n  params(specs: ParamSpecIterable): void {\n    if (this.cases !== null) {\n      throw new Error('test case is already parameterized');\n    }\n    const cases = Array.from(specs);\n    const seen: ParamsAny[] = [];\n    // This is n^2.\n    for (const spec of cases) {\n      if (seen.some(x => paramsEquals(x, spec))) {\n        throw new Error('Duplicate test case params');\n      }\n      seen.push(spec);\n    }\n    this.cases = cases;\n  }\n\n  *iterate(rec: TestSpecRecorder): IterableIterator<RunCase> {\n    for (const params of this.cases || [null]) {\n      yield new RunCaseSpecific(rec, { test: this.name, params }, this.fixture, this.fn);\n    }\n  }\n}\n\nclass RunCaseSpecific<F extends Fixture> implements RunCase {\n  readonly id: TestCaseID;\n  private readonly recorder: TestSpecRecorder;\n  private readonly fixture: FixtureClass<F>;\n  private readonly fn: TestFn<F>;\n\n  constructor(recorder: TestSpecRecorder, id: TestCaseID, fixture: FixtureClass<F>, fn: TestFn<F>) {\n    this.recorder = recorder;\n    this.id = id;\n    this.fixture = fixture;\n    this.fn = fn;\n  }\n\n  async run(debug: boolean): Promise<LiveTestCaseResult> {\n    const [rec, res] = this.recorder.record(this.id.test, this.id.params);\n    rec.start(debug);\n    try {\n      const inst = new this.fixture(rec, this.id.params || {});\n      await inst.init();\n      await this.fn(inst);\n      await inst.finalize();\n    } catch (e) {\n      rec.threw(e);\n    }\n    rec.finish();\n    return res;\n  }\n}\n"],"file":"test_group.js"}