{"version":3,"sources":["../../src/framework/fixture.ts"],"names":["Fixture","constructor","rec","params","init","debug","msg","log","finalize","numOutstandingAsyncExpectations","Error","warn","fail","ok","m","asyncExpectation","fn","ret","expectErrorValue","expectedName","ex","actualName","name","shouldReject","p","shouldThrow","expect","cond"],"mappings":";;;;;;AAGA;AACA;AACA;AACA,OAAO,MAAMA,OAAN,CAAc;AAKnBC,EAAAA,WAAW,CAACC,GAAD,EAAwBC,MAAxB,EAA2C;AAAA;;AAAA;;AAAA,6DAFZ,CAEY;;AACpD,SAAKD,GAAL,GAAWA,GAAX;AACA,SAAKC,MAAL,GAAcA,MAAd;AACD,GARkB,CAUnB;AACA;;;AACA,QAAMC,IAAN,GAA4B,CAAE;;AAE9BC,EAAAA,KAAK,CAACC,GAAD,EAAoB;AACvB,SAAKJ,GAAL,CAASG,KAAT,CAAeC,GAAf;AACD;;AAEDC,EAAAA,GAAG,CAACD,GAAD,EAAoB;AACrB,SAAKJ,GAAL,CAASK,GAAT,CAAaD,GAAb;AACD;;AAED,QAAME,QAAN,GAAgC;AAC9B,QAAI,KAAKC,+BAAL,KAAyC,CAA7C,EAAgD;AAC9C,YAAM,IAAIC,KAAJ,CACJ,6FADI,CAAN;AAGD;AACF;;AAEDC,EAAAA,IAAI,CAACL,GAAD,EAAqB;AACvB,SAAKJ,GAAL,CAASS,IAAT,CAAcL,GAAd;AACD;;AAEDM,EAAAA,IAAI,CAACN,GAAD,EAAqB;AACvB,SAAKJ,GAAL,CAASU,IAAT,CAAcN,GAAd;AACD;;AAEDO,EAAAA,EAAE,CAACP,GAAD,EAAqB;AACrB,UAAMQ,CAAC,GAAGR,GAAG,GAAG,OAAOA,GAAV,GAAgB,EAA7B;AACA,SAAKC,GAAL,CAAS,OAAOO,CAAhB;AACD;;AAED,QAAgBC,gBAAhB,CAAoCC,EAApC,EAAsE;AACpE,SAAKP,+BAAL;AACA,UAAMQ,GAAG,GAAG,MAAMD,EAAE,EAApB;AACA,SAAKP,+BAAL;AACA,WAAOQ,GAAP;AACD;;AAEOC,EAAAA,gBAAR,CAAyBC,YAAzB,EAA+CC,EAA/C,EAA4DN,CAA5D,EAA6E;AAC3E,QAAI,EAAEM,EAAE,YAAYV,KAAhB,CAAJ,EAA4B;AAC1B,WAAKE,IAAL,CAAU,iBAAV;AACA;AACD;;AACD,UAAMS,UAAU,GAAGD,EAAE,CAACE,IAAtB;;AACA,QAAID,UAAU,KAAKF,YAAnB,EAAiC;AAC/B,WAAKP,IAAL,CAAW,SAAQS,UAAW,eAAcF,YAAa,GAAEL,CAAE,EAA7D;AACD,KAFD,MAEO;AACL,WAAKD,EAAL,CAAS,SAAQQ,UAAW,GAAEP,CAAE,EAAhC;AACD;AACF;;AAED,QAAMS,YAAN,CAAmBJ,YAAnB,EAAyCK,CAAzC,EAA8DlB,GAA9D,EAA2F;AACzF,SAAKS,gBAAL,CAAsB,YAAY;AAChC,YAAMD,CAAC,GAAGR,GAAG,GAAG,OAAOA,GAAV,GAAgB,EAA7B;;AACA,UAAI;AACF,cAAMkB,CAAN;AACA,aAAKZ,IAAL,CAAU,kBAAkBE,CAA5B;AACD,OAHD,CAGE,OAAOM,EAAP,EAAW;AACX,aAAKF,gBAAL,CAAsBC,YAAtB,EAAoCC,EAApC,EAAwCN,CAAxC;AACD;AACF,KARD;AASD;;AAEDW,EAAAA,WAAW,CAACN,YAAD,EAAuBH,EAAvB,EAAuCV,GAAvC,EAA2D;AACpE,UAAMQ,CAAC,GAAGR,GAAG,GAAG,OAAOA,GAAV,GAAgB,EAA7B;;AACA,QAAI;AACFU,MAAAA,EAAE;AACF,WAAKJ,IAAL,CAAU,kBAAkBE,CAA5B;AACD,KAHD,CAGE,OAAOM,EAAP,EAAW;AACX,WAAKF,gBAAL,CAAsBC,YAAtB,EAAoCC,EAApC,EAAwCN,CAAxC;AACD;AACF;;AAEDY,EAAAA,MAAM,CAACC,IAAD,EAAgBrB,GAAhB,EAAuC;AAC3C,QAAIqB,IAAJ,EAAU;AACR,WAAKd,EAAL,CAAQP,GAAR;AACD,KAFD,MAEO;AACL,WAAKJ,GAAL,CAASU,IAAT,CAAcN,GAAd;AACD;;AACD,WAAOqB,IAAP;AACD;;AA5FkB","sourcesContent":["import { TestCaseRecorder } from './logger.js';\nimport { ParamsAny } from './params/index.js';\n\n// A Fixture is a class used to instantiate each test case at run time.\n// A new instance of the Fixture is created for every single test case\n// (i.e. every time the test function is run).\nexport class Fixture {\n  params: ParamsAny;\n  protected rec: TestCaseRecorder;\n  private numOutstandingAsyncExpectations = 0;\n\n  constructor(rec: TestCaseRecorder, params: ParamsAny) {\n    this.rec = rec;\n    this.params = params;\n  }\n\n  // This has to be a member function instead of an async `createFixture` function, because\n  // we need to be able to ergonomically override it in subclasses.\n  async init(): Promise<void> {}\n\n  debug(msg: string): void {\n    this.rec.debug(msg);\n  }\n\n  log(msg: string): void {\n    this.rec.log(msg);\n  }\n\n  async finalize(): Promise<void> {\n    if (this.numOutstandingAsyncExpectations !== 0) {\n      throw new Error(\n        'there were outstanding asynchronous expectations (e.g. shouldReject) at the end of the test'\n      );\n    }\n  }\n\n  warn(msg?: string): void {\n    this.rec.warn(msg);\n  }\n\n  fail(msg?: string): void {\n    this.rec.fail(msg);\n  }\n\n  ok(msg?: string): void {\n    const m = msg ? ': ' + msg : '';\n    this.log('OK' + m);\n  }\n\n  protected async asyncExpectation<T>(fn: () => Promise<T>): Promise<T> {\n    this.numOutstandingAsyncExpectations++;\n    const ret = await fn();\n    this.numOutstandingAsyncExpectations--;\n    return ret;\n  }\n\n  private expectErrorValue(expectedName: string, ex: unknown, m: string): void {\n    if (!(ex instanceof Error)) {\n      this.fail('THREW NON-ERROR');\n      return;\n    }\n    const actualName = ex.name;\n    if (actualName !== expectedName) {\n      this.fail(`THREW ${actualName} INSTEAD OF ${expectedName}${m}`);\n    } else {\n      this.ok(`threw ${actualName}${m}`);\n    }\n  }\n\n  async shouldReject(expectedName: string, p: Promise<unknown>, msg?: string): Promise<void> {\n    this.asyncExpectation(async () => {\n      const m = msg ? ': ' + msg : '';\n      try {\n        await p;\n        this.fail('DID NOT THROW' + m);\n      } catch (ex) {\n        this.expectErrorValue(expectedName, ex, m);\n      }\n    });\n  }\n\n  shouldThrow(expectedName: string, fn: () => void, msg?: string): void {\n    const m = msg ? ': ' + msg : '';\n    try {\n      fn();\n      this.fail('DID NOT THROW' + m);\n    } catch (ex) {\n      this.expectErrorValue(expectedName, ex, m);\n    }\n  }\n\n  expect(cond: boolean, msg?: string): boolean {\n    if (cond) {\n      this.ok(msg);\n    } else {\n      this.rec.fail(msg);\n    }\n    return cond;\n  }\n}\n"],"file":"fixture.js"}